Download telxcc version for Windows:
  https://github.com/forers/telxcc

Latest tested version:
  https://forers.com/download/telxcc/telxcc-windows-x86-v2.4.3.zip

Extract the following files here:
  telxcc.exe

------------------------------------------------------------------------------
Required telxcc patch to support M2TS files
------------------------------------------------------------------------------
As of Oct 2013, the current version of telxcc does not support M2TS files
(only TS files). To support M2TS files, use the following:

- Get the source files:
    git clone https://github.com/forers/telxcc.git telxcc
- Apply the patch below to telxcc.c
- On Windows with MinGW:
    mingw32-make -f Makefile.win
    strip telxcc.exe
- Copy the resulting telxcc.exe here.

@@ -72,10 +72,13 @@ typedef enum {
 #define TS_PACKET_PAYLOAD_SIZE (TS_PACKET_SIZE - 4)
 
 // size of a packet payload buffer
 #define PAYLOAD_BUFFER_SIZE 4096
 
+// size of timestamp header before TS packet in M2TS files in bytes
+#define M2TS_HEADER_SIZE 4
+
 typedef struct {
 	uint8_t sync;
 	uint8_t transport_error;
 	uint8_t payload_unit_start;
 	uint8_t transport_priority;
@@ -161,11 +164,12 @@ struct {
 	uint8_t colours; // output <font...></font> tags
 	uint8_t bom; // print UTF-8 BOM characters at the beginning of output
 	uint8_t nonempty; // produce at least one (dummy) frame
 	uint8_t se_mode; // search engine compatible mode
 	uint64_t utc_refvalue; // UTC referential value
-} config = { NULL, NULL, NO, 0, 0, 0, NO, NO, NO, NO, 0 };
+	size_t input_header_size; // size of extra header before TS packet in input file
+} config = { NULL, NULL, NO, 0, 0, 0, NO, NO, NO, NO, 0, 0 };
 
 FILE *fin = NULL;
 FILE *fout = NULL;
 
 // macro -- output only when increased verbosity was turned on
@@ -943,10 +947,11 @@ int main(const int argc, char *argv[]) {
 			fprintf(stderr, "  -1          produce at least one (dummy) frame\n");
 			fprintf(stderr, "  -c          output colour information in font HTML tags\n");
 			fprintf(stderr, "  -s [REF]    search engine mode;Â produce absolute timestamps in UTC and output data in one line\n");
 			fprintf(stderr, "              if REF (unix timestamp) is omitted, use current system time,\n");
 			fprintf(stderr, "              telxcc will automatically switch to transport stream UTC timestamps when available\n");
+			fprintf(stderr, "  -m          input file format is M2TS (BluRay and some IP-TV recorders)\n");
 			fprintf(stderr, "\n");
 			ret = EXIT_SUCCESS;
 			goto fail;
 		}
 		else if ((strcmp(argv[i], "-i") == 0) && (argc > i + 1)) {
@@ -987,10 +992,13 @@ int main(const int argc, char *argv[]) {
 				time_t now = time(NULL);
 				t = time(&now);
 			}
 			config.utc_refvalue = t;
 		}
+		else if (strcmp(argv[i], "-m") == 0) {
+			config.input_header_size = M2TS_HEADER_SIZE;
+		}
 		else {
 			fprintf(stderr, "! Unknown option %s\n", argv[i]);
 			fprintf(stderr, "- For usage options run \"%s -h\"\n\n", argv[0]);
 			goto fail;
 		}
@@ -1092,11 +1100,14 @@ int main(const int argc, char *argv[]) {
 	// PES packet buffer
 	uint8_t payload_buffer[PAYLOAD_BUFFER_SIZE] = { 0 };
 	uint16_t payload_counter = 0;
 
 	// reading input
-	while ((exit_request == NO) && (fread(&ts_buffer, 1, TS_PACKET_SIZE, fin) == TS_PACKET_SIZE)) {
+	while ((exit_request == NO) &&
+		(config.input_header_size == 0 || fread(&ts_buffer, 1, config.input_header_size, fin) == config.input_header_size) &&
+		(fread(&ts_buffer, 1, TS_PACKET_SIZE, fin) == TS_PACKET_SIZE)) {
+
 		// not TS packet -- misaligned?
 		if (ts_buffer[0] != 0x47) {
 			fprintf(stderr, "! Invalid TS packet header; TS seems to be misaligned\n");
 
 			for (uint16_t shift = 1; shift < TS_PACKET_SIZE; shift++) {
