//----------------------------------------------------------------------------
//
// Copyright (c) 2013, Thierry Lelegard
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
//
//----------------------------------------------------------------------------
//
// Define the class QtlMovieFFmpegVolumeDetect.
//
//----------------------------------------------------------------------------

#include "QtlMovieFFmpegVolumeDetect.h"
#include "QtlMovieFFmpeg.h"
#include "QtlMovie.h"
#include "QtlStringList.h"


//----------------------------------------------------------------------------
// Build the FFmpeg command line options.
//----------------------------------------------------------------------------

QStringList QtlMovieFFmpegVolumeDetect::commandLineOptions(const QString& inputFile, const QString& audioStream, const QtlMovieSettings* settings)
{
    // Complete command line. We drop all video streams (-vn).
    // But note that we must not specific an audio codec, even -codec:a copy,
    // otherwise the volumedetect filter does not display anything.
    QStringList args;
    args << "-nostdin"               // Do not attempt to read from standard input.
         << "-stats"                 // Print progress report (caught by our output analysis).
         << "-loglevel" << "info"    // Must report info.
         << QtlMovieFFmpeg::probeArguments(settings)
         << "-fflags" << "+genpts"   // Make FFmpeg generate PTS (time stamps).
         << "-i" << inputFile        // Input file containing the audio.
         << "-map" << audioStream    // Audio stream selection.
         << "-af" << "volumedetect"  // Run "volumedetect" filter on this audio stream.
         << "-vn"                    // Drop video.
         << QtlMovieFFmpeg::outputArguments(settings, QTL_NULL_DEVICE, "null"); // Drop output
    return args;
}


//----------------------------------------------------------------------------
// Constructor
//----------------------------------------------------------------------------

QtlMovieFFmpegVolumeDetect::QtlMovieFFmpegVolumeDetect(const QString& inputFile,
                                                       const QString& audioStream,
                                                       int inputDurationInSeconds,
                                                       const QString& temporaryDirectory,
                                                       const QtlMovieSettings* settings,
                                                       QtlLogger* log,
                                                       QObject* parent) :
    QtlMovieFFmpegProcess(commandLineOptions(inputFile, audioStream, settings),
                          inputDurationInSeconds,
                          temporaryDirectory,
                          settings,
                          log,
                          parent),
    _meanLevel(0.0),
    _peakLevel(0.0)
{
}


//----------------------------------------------------------------------------
// Process one text line from standard error.
//----------------------------------------------------------------------------

void QtlMovieFFmpegVolumeDetect::processOutputLine(QProcess::ProcessChannel channel, const QString& line)
{
    // Intercept all lines which are generated by the "volumedetect" filter.
    if (line.contains("[Parsed_volumedetect_", Qt::CaseInsensitive)) {

        // Determine which value it is, intercept mean_volume and max_volume.
        float* value = 0;
        if (line.contains("mean_volume:", Qt::CaseInsensitive)) {
            value = &_meanLevel;
        }
        else if (line.contains("max_volume:", Qt::CaseInsensitive)) {
            value = &_peakLevel;
        }

        // Extract the value, sample expected end of line: ": -19.4 dB"
        if (value != 0) {
            QString line1(line);
            line1.replace(QRegExp("^.*:\\s*"), "");
            line1.replace(QRegExp("\\s+.*$"), "");
            bool ok = false;
            const float f = line1.toFloat(&ok);
            if (ok) {
                *value = f;
            }
        }
    }

    // Invoke superclass
    QtlMovieFFmpegProcess::processOutputLine(channel, line);
}


//----------------------------------------------------------------------------
// Emit the completed() signal.
//----------------------------------------------------------------------------

void QtlMovieFFmpegVolumeDetect::emitCompleted(bool success, const QString& message)
{
    // Build and register the required audio filter if necessary.
    buildAudioFilter();

    // Invoke superclass
    QtlMovieFFmpegProcess::emitCompleted(success, message);
}


//----------------------------------------------------------------------------
// Build the audio filter for audio normalization.
//----------------------------------------------------------------------------

void QtlMovieFFmpegVolumeDetect::buildAudioFilter()
{
    // No audio level found or no normalization required.
    if (_meanLevel >= 0.0 || _peakLevel <= _meanLevel || !settings()->audioNormalize()) {
        return;
    }

    // Report audio levels.
    line(tr("Audio volume analysis completed, mean level = %1 dBFS, peak level = %2 dBFS").arg(_meanLevel).arg(_peakLevel));

    // Target audio levels.
    const float outMean = float(settings()->audioNormalizeMean());
    const float outPeak = float(settings()->audioNormalizePeak());

    // Check configuration consistency.
    if (outPeak <= outMean) {
        line(tr("Inconsistent audio normalization settings, max peak level (%1 dBFS) must be greater than mean level (%2 dBFS)").arg(outPeak).arg(outMean), QColor("red"));
        return;
    }

    // Perform audio normalization only if the input mean level is far enough from the target.
    if (qAbs(_meanLevel - outMean) <= QTL_AUDIO_NORMALIZATION_TOLERANCE) {
        line(tr("Audio volume is close enough to the normalized level, will not normalize"));
        return;
    }

    // Compute input and output dynamic ranges.
    const float inDynamics = _peakLevel - _meanLevel;
    const float outDynamics = outPeak - outMean;

    // Compute the audio filter.
    QString audioFilter;
    if (inDynamics <= outDynamics || settings()->audioNormalizeMode() == QtlMovieSettings::Clip) {
        // The input dynamics is in the output range, simply adjust the volume to the target mean level.
        // Same if we clip the audio in case the input dynamics is too large.
        audioFilter = volumeFilter(outMean - _meanLevel);
    }
    else if (settings()->audioNormalizeMode() == QtlMovieSettings::AlignPeak) {
        // The input dynamics is too large and we simply adjust the volume to align the peak level.
        audioFilter = volumeFilter(outPeak - _peakLevel);
    }
    else {
        // The input dynamics is too large and we must compress the dynamics.
        audioFilter = compandFilter(_meanLevel, _peakLevel, outMean, outPeak);
    }
    debug(tr("Audio filter: \"%1\"").arg(audioFilter));

    // Store the audio filter options for FFmpeg in the job.
    if (!audioFilter.isEmpty()) {
        setJobVariable(QTL_AUDIO_FILTER_VARNAME, QtlStringList("-af", audioFilter));
    }
}


//----------------------------------------------------------------------------
// Build a "volume" filter.
//----------------------------------------------------------------------------

QString QtlMovieFFmpegVolumeDetect::volumeFilter(float offset)
{
    return QStringLiteral("volume=%1%2dB").arg(offset > 0.0 ? "+" : "").arg(offset, 0, 'f', 1);
}


//----------------------------------------------------------------------------
// Build a "compand" filter.
//----------------------------------------------------------------------------

QString QtlMovieFFmpegVolumeDetect::compandFilter(float inMean, float inPeak, float outMean, float outPeak)
{
    line(tr("The audio compression is not yet supported, aligning on peak level instead"), QColor("red"));
    return volumeFilter(outPeak - inPeak);
}
